

        /*
        // prepara os valores para o seletor de nível
        String [] levels = new String [Levels.maxNumberOfLevels-1];
        for (int i = 0; i < Levels.maxNumberOfLevels-1; i++){
            levels[i] = Integer.toString(i+1);
        }

        // cria o seletor de nível
        selectorLevel = new Selector("selectorLevel", 0f,0f, fontSize, "", levels, font);
        selectorLevel.setSelectedValue(SaveGame.saveGame.currentLevelNumber - 1);

        // adiciona a opção de selecionar nível
        menuMain.addMenuOption("SelecionarNivel", getContext().getResources().getString(R.string.menuPrincipalAlterarNivel), new MenuOption.OnChoice() {
            @Override
            public void onChoice() {
                selectorLevel.setSelectedValue(SaveGame.saveGame.currentLevelNumber - 1);
                Game.selectorLevel.fromMenu(innerMenu);
            }
        });

        // ajusta a posição do seletor de nível
        MenuOption menuOptionSelectLevel = menuMain.getMenuOptionByName("SelecionarNivel");
        selectorLevel.setPosition(menuOptionSelectLevel.x + (menuOptionSelectLevel.width), menuOptionSelectLevel.y);
        selectorLevel.setOnChange(new Selector.OnChange() {
            @Override
            public void onChange() {
                Game.changeLevel(Game.selectorLevel.selectedValue+1);
            }
        });

        */


        /*

        // cria o seletor de dificuldade
        selectorDificulty = new Selector("selectorDificulty", 0f,0f, fontSize, "",
                new String[]{getContext().getResources().getString(R.string.facil),
                        getContext().getResources().getString(R.string.normal),
                        getContext().getResources().getString(R.string.dificil),
                        getContext().getResources().getString(R.string.insano)
                }, font);
        menuOptions.addMenuOption("dificuldade", getContext().getResources().getString(R.string.dificuldade), new MenuOption.OnChoice() {
            @Override
            public void onChoice() {
                Game.selectorDificulty.fromMenu(Game.menuOptions);
                if (SaveGame.saveGame.currentDifficulty == DIFFICULTY_EASY){
                    selectorDificulty.setSelectedValue(0);
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeFacil));
                } else if (SaveGame.saveGame.currentDifficulty == DIFFICULTY_NORMAL){
                    selectorDificulty.setSelectedValue(1);
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeNormal));
                } else if (SaveGame.saveGame.currentDifficulty == DIFFICULTY_HARD){
                    selectorDificulty.setSelectedValue(2);
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeDificil));
                } else if (SaveGame.saveGame.currentDifficulty == DIFFICULTY_INSANE){
                    selectorDificulty.setSelectedValue(3);
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeInsano));
                }
            }
        });

        final MenuOption menuOptionDificuldade = menuOptions.getMenuOptionByName("dificuldade");
        selectorDificulty.setPosition(menuOptionDificuldade.x + (menuOptionDificuldade.width * 1.2f), menuOptionDificuldade.y);

        selectorDificulty.setOnChange(new Selector.OnChange() {
            @Override
            public void onChange() {
                Game.changeDifficulty(selectorDificulty.selectedValue);
                if (selectorDificulty.selectedValue == 0){
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeFacil));
                } else if (selectorDificulty.selectedValue == 1){
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeNormal));
                } else if (selectorDificulty.selectedValue == 2){
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeDificil));
                } else if (selectorDificulty.selectedValue == 3){
                    setBottomText(getContext().getResources().getString(R.string.mensagemDificuldadeInsano));
                }
            }
        });

        selectorDificulty.setOnConclude(new Selector.OnConclude() {
            @Override
            public void onConclude() {
                setBottomText("");
            }
        });

        */



// BOTÃO SOM
        Game.buttonSound = new ButtonOnOff("buttonSound", Game.gameAreaResolutionX * 0.34f,
                Game.resolutionY * 0.89f, Game.resolutionY * 0.06f, Game.resolutionY * 0.06f, Texture.TEXTURE_BUTTONS_AND_BALLS, 1.2f);
        Game.buttonSound.textureMapUnpressed = 9;
        Game.buttonSound.textureMapPressed = 10;
        Game.buttonSound.getListener().x = Game.gameAreaResolutionX * 0.32f;
        Game.buttonSound.getListener().y = Game.resolutionY * 0.86f;
        Game.buttonSound.getListener().width = Game.gameAreaResolutionX * 0.12f;
        Game.buttonSound.getListener().height = Game.resolutionY * 0.12f;

        Game.buttonSound.alpha = 0.5f;
        if (SaveGame.saveGame.sound) {
            Game.buttonSound.setOn();
        } else {
            Game.buttonSound.setOff();
        }

        Game.buttonSound.setOnOffBehavior(new ButtonOnOff.OnOffBehavior() {
            @Override
            public void onBehavior() {
                SaveGame.saveGame.sound = true;
            }

            @Override
            public void offBehavior() {
                SaveGame.saveGame.sound = false;
            }
        });

        // BOTÃO MUSICA
        Game.buttonMusic = new ButtonOnOff("buttonMusic",Game.gameAreaResolutionX * 0.61f,
                Game.resolutionY * 0.89f, Game.resolutionY * 0.06f, Game.resolutionY * 0.06f, Texture.TEXTURE_BUTTONS_AND_BALLS, 1.2f);
        Game.buttonMusic.textureMapUnpressed = 2;
        Game.buttonMusic.textureMapPressed = 1;
        Game.buttonMusic.alpha = 0.5f;
        Game.buttonMusic.getListener().x = Game.gameAreaResolutionX * 0.58f;
        Game.buttonMusic.getListener().y = Game.resolutionY * 0.86f;
        Game.buttonMusic.getListener().width = Game.gameAreaResolutionX * 0.12f;
        Game.buttonMusic.getListener().height = Game.resolutionY * 0.12f;
        if (SaveGame.saveGame.music) {
            Game.buttonMusic.setOn();
        } else {
            Game.buttonMusic.setOff();
        }

        Game.buttonMusic.setOnOffBehavior(new ButtonOnOff.OnOffBehavior() {
            @Override
            public void onBehavior() {
                SaveGame.saveGame.music = true;
                if (Sound.music != null){
                    Sound.music.setVolume(0.006f* (float) 50, 0.006f* (float) 50);
                    Sound.music.start();
                }
            }

            @Override
            public void offBehavior() {
                SaveGame.saveGame.music = false;
                if (Sound.music != null){
                    Sound.music.pause();
                }
            }
        });



---------------------
package com.marcelslum.ultnogame;



import android.app.Activity;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.opengl.GLSurfaceView;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.RelativeLayout;
import com.google.android.gms.ads.AdListener;
import com.google.android.gms.ads.AdRequest;
import com.google.android.gms.ads.InterstitialAd;
import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.games.Games;
import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;

public class MainActivity extends FragmentActivity implements
        OnConnectionFailedListener {


    private static final int REQUEST_ACHIEVEMENTS = 2001;
    private static final int REQUEST_LEADERBOARD = 3001;

    private GLSurfaceView glSurfaceView;

    private InterstitialAd interstitial;

	public GoogleApiClient mGoogleApiClient;

    private static int RC_SIGN_IN = 9001;
    private boolean mResolvingConnectionFailure = false;
    private boolean mAutoStartSignInflow = true;
    private boolean mSignInClicked = false;

    public boolean connected = false;

    private static String STATE_RESOLVING_ERROR = "re";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Game.mainActivity = this;
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
        initAds();
        mResolvingConnectionFailure = savedInstanceState != null && savedInstanceState.getBoolean(STATE_RESOLVING_ERROR, false);



        mGoogleApiClient = new GoogleApiClient.Builder(this)
                .enableAutoManage(this /* FragmentActivity */,
                        this /* OnConnectionFailedListener */)
                //.addConnectionCallbacks(this)
                //.addOnConnectionFailedListener(this)
                .addApi(Games.API).addScope(Games.SCOPE_GAMES)
                .build();

        mGoogleApiClient.connect();


        // Fullscreen mode
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
        getWindow().getDecorView().setOnSystemUiVisibilityChangeListener(new View.OnSystemUiVisibilityChangeListener() {
            @Override
            public void onSystemUiVisibilityChange(int visibility) {
                if ((visibility & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) {
                    // TODO: The system bars are visible. Make any desired
                    if (Game.gameState == Game.GAME_STATE_JOGAR) {
                        Game.setGameState(Game.GAME_STATE_PAUSE);
                    }
                } else {
                    // TODO: The system bars are NOT visible. Make any desired
                }
            }
        });
        glSurfaceView = new GLSurf(this);
        glSurfaceView.setPreserveEGLContextOnPause(true);
        setContentView(R.layout.activity_main);
        RelativeLayout layout = (RelativeLayout) findViewById(R.id.gamelayout);
        RelativeLayout.LayoutParams glParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        layout.addView(glSurfaceView, glParams);

    }

	@Override
	protected void onSaveInstanceState(Bundle outState) {
	    super.onSaveInstanceState(outState);
	    outState.putBoolean(STATE_RESOLVING_ERROR, mResolvingConnectionFailure);
	}

    @Override
    public void onConnected(Bundle connectionHint) {
        Log.e("mainActivity", "onConnected(Bundle connectionHint)");
        ConnectionHandler.mGoogleApiClientConected = true;
    }

    @Override
    public void onConnectionFailed(ConnectionResult connectionResult) {
        if (mResolvingConnectionFailure) {
            return;
        }

        if (mSignInClicked || mAutoStartSignInflow) {
            mAutoStartSignInflow = false;
            mSignInClicked = false;
            mResolvingConnectionFailure = true;

            // Attempt to resolve the connection failure using BaseGameUtils.
            // The R.string.signin_other_error value should reference a generic
            // error string in your strings.xml file, such as "There was
            // an issue with sign-in, please try again later."

            if (!BaseGameUtils2.resolveConnectionFailure(this,
                    mGoogleApiClient, connectionResult,
                    RC_SIGN_IN, getResources().getString(R.string.signin_other_error))) {
                mResolvingConnectionFailure = false;
            }
        }
        Splash.setSplashMessage(Splash.AGUARDA_MESSAGE_GOOGLE_NAO_CONECTADO);
    }

    @Override
    public void onConnectionSuspended(int i) {
        mGoogleApiClient.connect();
    }

    protected void onActivityResult(int requestCode, int resultCode,
                                    Intent intent) {

        Log.e("main activity", "onActivityResult " + resultCode);
        if (requestCode == RC_SIGN_IN) {
            mSignInClicked = false;
            mResolvingConnectionFailure = false;
            if (resultCode == RESULT_OK) {
                mGoogleApiClient.connect();
            } else {
                // Bring up an error dialog to alert the user that sign-in
                // failed. The R.string.signin_failure should reference an error
                // string in your strings.xml file that tells the user they
                // could not be signed in, such as "Unable to sign in."
                BaseGameUtils2.showActivityResultError(this,
                        requestCode, resultCode, R.string.signin_failure);
            }
        }
    }

	private void initAds(){
		interstitial = new InterstitialAd(MainActivity.this);
		interstitial.setAdUnitId("ca-app-pub-2413920269734587/2998542956");

		AdRequest adRequest = new AdRequest.Builder()
		    .addTestDevice(AdRequest.DEVICE_ID_EMULATOR)
		    .addTestDevice("9BDF327E8C4CD72B8C5DC02B20DD551B")
            .addTestDevice("AB221C24C4F00E7425323CFD691D8964")
		    .build();
		interstitial.loadAd(adRequest);
		interstitial.setAdListener(new AdListener() {
		    @Override
		    public void onAdLoaded() {
			}

		    @Override
		    public void onAdClosed() {
			    if (Game.gameState != Game.GAME_STATE_INTRO){
                    Log.e("GLRenderer", "setGameState MENU");
                    Game.setGameState(Game.GAME_STATE_MENU);
                }
		    }

		    @Override
		    public void onAdFailedToLoad(int errorCode) {
			    //Game.setGameState(Game.GAME_STATE_MENU);
		    }

		    @Override
		    public void onAdLeftApplication() {
		    }

		    @Override
		    public void onAdOpened() {
		    }
		});
		interstitial.loadAd(adRequest);

	}

	private void setFullScreen() {
		int uiOptions = this.getWindow().getDecorView().getSystemUiVisibility();
		if (Build.VERSION.SDK_INT >= 14) {
		    uiOptions ^= View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
		}
		if (Build.VERSION.SDK_INT >= 16) {
		    uiOptions ^= View.SYSTEM_UI_FLAG_FULLSCREEN;
		}
		if (Build.VERSION.SDK_INT >= 18) {
		    uiOptions ^= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
		}

		this.getWindow().getDecorView().setSystemUiVisibility(uiOptions);
	}

    @Override
    protected void onStart() {
        super.onStart();
        mGoogleApiClient.connect();
    }

    @Override
    protected void onStop() {
        super.onStop();
        if (mGoogleApiClient.isConnected()) {
            mGoogleApiClient.disconnect();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        glSurfaceView.onPause();
    }

    @Override
    public void onBackPressed() {
        if (Game.gameState == Game.GAME_STATE_JOGAR) {
            Game.setGameState(Game.GAME_STATE_PAUSE);
        } else if (Game.gameState == Game.GAME_STATE_MENU) {
            super.onPause();
            glSurfaceView.onPause();
            moveTaskToBack(true);
        } else {
            Game.setGameState(Game.GAME_STATE_MENU);
        }
    }

    public void showInterstitial() {
        runOnUiThread(new Runnable() {
            public void run() {
                if (interstitial.isLoaded()) {
                    interstitial.show();
                } else {
                    //Log.d(TAG, "Interstitial ad is not loaded yet");
                }
            }
        });
    }

    @Override
    protected void onResume() {
        super.onResume();
        setFullScreen();
        glSurfaceView.onResume();
    }

    public void unlockAchievement() {
        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {
            Games.Achievements.unlock(mGoogleApiClient, "CgkIjNyO58cTEAIQAQ");
        } else {
            // Alternative implementation (or warn user that they must sign in to use this feature)
        }
    }

    public void showAchievements(){
        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {
            // Call a Play Games services API method, for example:
            Games.Achievements.unlock(mGoogleApiClient, "CgkIjNyO58cTEAIQAQ");

            Intent intent = Games.Achievements.getAchievementsIntent(mGoogleApiClient);

            startActivityForResult(intent,
                    REQUEST_ACHIEVEMENTS);
        } else {
            // Alternative implementation (or warn user that they must
            // sign in to use this feature)
        }
    }

    public void showLeaderboards(){
        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {
            startActivityForResult(Games.Leaderboards.getLeaderboardIntent(mGoogleApiClient,
                    "CgkIjNyO58cTEAIQAg"), REQUEST_LEADERBOARD);
        } else {
            Log.e("mainActivity", "não conectado");
        }
    }

    public void submitScore() {
        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {
            Games.Leaderboards.submitScore(mGoogleApiClient, "CgkIjNyO58cTEAIQAg", 12333);
        } else {
            Log.e("mainActivity", "não conectado");

            // Alternative implementation (or warn user that they must sign in to use this feature)
        }
    }

    public void connectMGoogleApiClient() {
        Log.e("mainActivity", "mGoogleApiClient.connect();");
        mGoogleApiClient.connect();
    }
}













 Target(String name, Game game, float x, float y, float width, float height, int weight, int [] states, int currentState, int special, boolean ghost){
        super(name, game, x, y, width, height, weight, new Color(0,0,0,1));
        this.states = states;
        this.currentState = currentState;
        this.special = special;
        setType();
        textureId = Game.TEXTURE_TARGETS;
        program = this.game.imageProgram;
        isMovable = false;
        isGhost = ghost;

        this.setDrawInfo();

        ArrayList<float[]> valuesAnimationShowPoints = new ArrayList<>();
        valuesAnimationShowPoints.add(new float[]{0f,1f});
        valuesAnimationShowPoints.add(new float[]{1f,0f});
        showPointsStateAnim = new Animation(this, "showPointsState", "showPointsState", 1000, valuesAnimationShowPoints, false, false);

        ArrayList<float[]> valuesAnimationShowPointsAlpha = new ArrayList<>();
        valuesAnimationShowPointsAlpha.add(new float[]{0f,1f});
        valuesAnimationShowPointsAlpha.add(new float[]{1f,0f});
        showPointsAlphaAnim = new Animation(this, "pointsAlpha", "pointsAlpha", 1000, valuesAnimationShowPointsAlpha, false, true);

        ArrayList<float[]> valuesAnimationGhostAlpha = new ArrayList<>();
        valuesAnimationGhostAlpha.add(new float[]{0f,1f});
        valuesAnimationGhostAlpha.add(new float[]{1f,0f});
        ghostAlphaAnim = new Animation(this, "ghostAlpha", "ghostAlpha", 1000, valuesAnimationGhostAlpha, false, true);

        ArrayList<float[]> valuesAnimation = new ArrayList<>();
        valuesAnimation.add(new float[]{0f,1f});
        valuesAnimation.add(new float[]{0.3f,0.10f});
        valuesAnimation.add(new float[]{0.4f,0f});
        valuesAnimation.add(new float[]{1f,0f});
        desapearAnim = new Animation(this, "desapear", "alpha", 1000, valuesAnimation, false, true);
        final Target self = this;
        desapearAnim .setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationEnd() {
                self.isVisible = false;
            }
        });
    }

 public void UpdateSprite()
    {
        // Get new transformed vertices
        //vertices = sprite.getTransformedVertices();

        // The vertex buffer.
        ByteBuffer bb = ByteBuffer.allocateDirect(vertices.length * 4);
        bb.order(ByteOrder.nativeOrder());
        vertexBuffer = bb.asFloatBuffer();
        vertexBuffer.put(vertices);
        vertexBuffer.position(0);
    }

 class Sprite
    {
        float angle;
        float scale;
        RectF base;
        PointF translation;

        public Sprite()
        {
            // Initialise our intital size around the 0,0 point
            base = new RectF(-50f*ssu,50f*ssu, 50f*ssu, -50f*ssu);

            // Initial translation
            translation = new PointF(50f*ssu,50f*ssu);

            // We start with our inital size
            scale = 1f;

            // We start in our inital angle
            angle = 0f;
        }


        public void translate(float deltax, float deltay)
        {
            // Update our location.
            translation.x += deltax;
            translation.y += deltay;
        }

        public void scale(float deltas)
        {
            scale += deltas;
        }

        public void rotate(float deltaa)
        {
            angle += deltaa;
        }

        public float[] getTransformedVertices()
        {
            // Start with scaling
            float x1 = base.left * scale;
            float x2 = base.right * scale;
            float y1 = base.bottom * scale;
            float y2 = base.top * scale;

            // We now detach from our Rect because when rotating,
            // we need the seperate points, so we do so in opengl order
            PointF one = new PointF(x1, y2);
            PointF two = new PointF(x1, y1);
            PointF three = new PointF(x2, y1);
            PointF four = new PointF(x2, y2);

            // We create the sin and cos function once,
            // so we do not have calculate them each time.
            float s = (float) Math.sin(angle);
            float c = (float) Math.cos(angle);

            // Then we rotate each point
            one.x = x1 * c - y2 * s;
            one.y = x1 * s + y2 * c;
            two.x = x1 * c - y1 * s;
            two.y = x1 * s + y1 * c;
            three.x = x2 * c - y1 * s;
            three.y = x2 * s + y1 * c;
            four.x = x2 * c - y2 * s;
            four.y = x2 * s + y2 * c;

            // Finally we translate the sprite to its correct position.
            one.x += translation.x;
            one.y += translation.y;
            two.x += translation.x;
            two.y += translation.y;
            three.x += translation.x;
            three.y += translation.y;
            four.x += translation.x;
            four.y += translation.y;

            // We now return our float array of vertices.
            return new float[]
                    {
                            one.x, one.y, 0.0f,
                            two.x, two.y, 0.0f,
                            three.x, three.y, 0.0f,
                            four.x, four.y, 0.0f,
                    };
        }
    }

public void SetupTriangle()
{
    // We will need a randomizer
    Random rnd = new Random();

    // We have to create the vertices of our triangle.
    vertices = new float[]
            {       0.0f, 300f, 0.0f,
                    120.0f, 300.0f, 0.0f,
                    120.0f, 340.0f, 0.0f,
                    0.0f, 340, 0.0f,
                    125.0f, 300.0f, 0.0f,
                    245.0f, 300.0f, 0.0f,
                    245.0f, 340.0f, 0.0f,
                    125.0f, 340.0f, 0.0f,
                    250.0f, 300.0f, 0.0f,
                    370.0f, 300.0f, 0.0f,
                    370.0f, 340.0f, 0.0f,
                    250.0f, 340.0f, 0.0f,
            };

    indices = new short[] {0, 1, 2, 0, 2, 3, 0+4, 1+4, 2+4, 0+4, 2+4, 3+4, 0+8, 1+8, 2+8, 0+8, 2+8, 3+8}; // The order of vertexrendering.

    // The vertex buffer.
    ByteBuffer bb = ByteBuffer.allocateDirect(vertices.length * 4);
    bb.order(ByteOrder.nativeOrder());
    vertexBuffer = bb.asFloatBuffer();
    vertexBuffer.put(vertices);
    vertexBuffer.position(0);

    // initialize byte buffer for the draw list
    ByteBuffer dlb = ByteBuffer.allocateDirect(indices.length * 2);
    dlb.order(ByteOrder.nativeOrder());
    drawListBuffer = dlb.asShortBuffer();
    drawListBuffer.put(indices);
    drawListBuffer.position(0);
}

public void SetupTargets(){

    int totalObjects = this.gi.targets.size() + this.gi.balls.size();

    uvs = new float[totalObjects * 8];

    int i;

    for (i = 0; i < this.gi.targets.size(); i++){
        this.gi.targets.get(i).insertUvData(uvs, i*8);
    };

    int offset = i;

    for (i = 0; i < this.gi.balls.size(); i++){
        this.gi.balls.get(i).insertUvData(uvs, (i+offset)*8);
    };

    // The texture buffer
    ByteBuffer bb1 = ByteBuffer.allocateDirect(uvs.length * 4);
    bb1.order(ByteOrder.nativeOrder());
    uvBuffer = bb1.asFloatBuffer();
    uvBuffer.put(uvs);
    uvBuffer.position(0);

    vertices = new float[totalObjects * 12];


    for (i = 0; i < this.gi.targets.size(); i++){
        this.gi.targets.get(i).insertVerticesData(vertices, i*12);
    };

    offset = i;

    for (i = 0; i < this.gi.balls.size(); i++){
        this.gi.balls.get(i).insertVerticesData(vertices, (i+offset)*12);
    };

    indices = new short[totalObjects * 6];

    for (i = 0; i < this.gi.targets.size(); i++) {
        this.gi.targets.get(i).insertIndicesData(indices, i*6, i*4);
    }

    offset = i;

    for (i = 0; i < this.gi.balls.size(); i++){
        this.gi.balls.get(i).insertIndicesData(indices, (i+offset)*6, (i+offset)*4);
    };

    // The vertex buffer.
    ByteBuffer bb2 = ByteBuffer.allocateDirect(vertices.length * 4);
    bb2.order(ByteOrder.nativeOrder());
    vertexBuffer = bb2.asFloatBuffer();
    vertexBuffer.put(vertices);
    vertexBuffer.position(0);

    // initialize byte buffer for the draw list
    ByteBuffer bb3 = ByteBuffer.allocateDirect(indices.length * 2);
    bb3.order(ByteOrder.nativeOrder());
    drawListBuffer = bb3.asShortBuffer();
    drawListBuffer.put(indices);
    drawListBuffer.position(0);
}




 public void SetupImage()
    {
        // Generate Textures, if more needed, alter these numbers.
        int[] texturenames = new int[2];
        GLES20.glGenTextures(2, texturenames, 0);

        // Retrieve our image from resources.
        int id = mContext.getResources().getIdentifier("drawable/texturas3", null, mContext.getPackageName());

        // Temporary create a bitmap
        Bitmap bmp = BitmapFactory.decodeResource(mContext.getResources(), id);

        // Bind texture to texturename
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texturenames[0]);

        // Set filtering
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);

        // Load the bitmap into the bound texture.
        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bmp, 0);

        // We are done using the bitmap so we should recycle it.
        bmp.recycle();

        // Again for the text texture
        id = mContext.getResources().getIdentifier("drawable/font", null, mContext.getPackageName());
        bmp = BitmapFactory.decodeResource(mContext.getResources(), id);
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + 1);
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texturenames[1]);
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bmp, 0);
        bmp.recycle();
    }

 public void SetupText()
    {
        /*
        // Create our text manager
        tm = new TextManager();

        // Tell our text manager to use index 1 of textures loaded
        tm.setTextureID(1);

        // Create our new textobject
        //Text txt = new Text("esta é um teste do texto", 0f, 0f, 100.f);

        // Add it to our manager
        tm.addText(txt);

        // Create our new textobject
        Text txt2 = new Text("ULTNO", 0, 200f, 400.f);

        // Add it to our manager
        tm.addText(txt2);

        Log.e("width of ultno", " "+tm.getWidth(txt2));

        // Prepare the text for rendering
        tm.PrepareDraw();
        */
    }


     private void UpdatePositions(){
 /*
         for (int i = 0; i < this.gi.balls.size(); i++) {

             Ball ball = this.gi.balls.get(i);
             if (ball.bUp) {
                 ball.x += 5;
                 ball.y += 5;
                 if (ball.x > 400) {
                     ball.bUp = false;
                 }
             } else {
                 ball.x -= 5;
                 ball.y -= 5;
                 if (ball.x < 100) {
                     ball.bUp = true;
                 }
             }
         }



         int totalObjects = this.gi.targets.size() + this.gi.balls.size();

         vertices = new float[totalObjects * 12];

         int i;

         for (i = 0; i < this.gi.targets.size(); i++){
             this.gi.targets.get(i).insertVerticesData(vertices, i*12);
         };

         int offset = i;

         for (i = 0; i < this.gi.balls.size(); i++){
             this.gi.balls.get(i).insertVerticesData(vertices, (i+offset)*12);
         };

         ByteBuffer bb = ByteBuffer.allocateDirect(vertices.length * 4);
         bb.order(ByteOrder.nativeOrder());
         vertexBuffer = bb.asFloatBuffer();
         vertexBuffer.put(vertices);
         vertexBuffer.position(0);

         */
     }

         public void SetupEntities(){

             //this.gi.targets.clear();

             //this.gi.addTarget(new Target("target", this.gi, 0.0f, 400.0f, 480.0f, 30.0f, 10));
             //this.gi.addTarget(new Target("target", this.gi, 0.0f, 400.0f, effectiveScreenWidth, 30.0f, 10));
             //this.gi.addTarget(new Target("target", this.gi, 0.0f, 300.0f, effectiveScreenWidth-10, 30.0f, 10));

             //this.gi.addTarget(new Target("target", this.gi, 0.0f, 0.0f, 10f, effectiveScreenHeight-10, 10));
             /*
             //Log.e("tag setup entities1", " ");



             this.gi.addBall(new Ball("ball", this.gi, 100f, 100f, 10f, 8));
             this.gi.balls.get(0).program = this.imageProgram;
             this.gi.balls.get(0).textureId = 0;
             this.gi.balls.get(0).vx = 12.1f;
             this.gi.balls.get(0).vy = 12.1f;



             this.gi.addBall(new Ball("ball", this.gi, 200f, 200f, 16f, 8));
             this.gi.balls.get(1).program = this.imageProgram;
             this.gi.balls.get(1).textureId = 0;

             this.gi.balls.get(1).vx = 18.1f;
             this.gi.balls.get(1).vy = 18.1f;

             this.gi.addBall(new Ball("ball", this.gi, 300f, 300f, 5f, 8));
             this.gi.balls.get(2).program = this.imageProgram;
             this.gi.balls.get(2).textureId = 0;

             this.gi.balls.get(2).vx = 7.1f;
             this.gi.balls.get(2).vy = 7.1f;

             this.gi.addBall(new Ball("ball", this.gi, 250f, 110f, 13f, 8));
             this.gi.balls.get(3).program = this.imageProgram;
             this.gi.balls.get(3).textureId = 0;
             this.gi.balls.get(3).vx = 6.1f;
             this.gi.balls.get(3).vy = 6.1f;

             this.gi.addBall(new Ball("ball", this.gi, 250f, 190f, 5f, 8));
             this.gi.balls.get(4).program = this.imageProgram;
             this.gi.balls.get(4).textureId = 0;
             this.gi.balls.get(4).vx = 8.1f;
             this.gi.balls.get(4).vy = 8.1f;

             this.gi.addBall(new Ball("ball", this.gi, 250f, 310f, 15f, 8));
             this.gi.balls.get(5).program = this.imageProgram;
             this.gi.balls.get(5).textureId = 0;
             this.gi.balls.get(5).vx = 2.1f;
             this.gi.balls.get(5).vy = 2.1f;
             //Log.e("tag setup entities2", " ");





             //Log.e("tag setup entities3", " ");





             this.gi.bordaE = new Rectangle("bordaE", this.gi, -999, -this.gi.gameAreaResolutionY, 1000, this.gi.gameAreaResolutionY*3, 10, new Color(0,0,0,1));
             this.gi.bordaE.isMovable = false;
             this.gi.bordaE.program = this.solidProgram;

             this.gi.bordaD = new Rectangle("bordaD", this.gi, this.gi.gameAreaResolutionX-2, -this.gi.gameAreaResolutionY, 1000, this.gi.gameAreaResolutionY*3, 10, new Color(0,0,0,1));
             this.gi.bordaD.isMovable = false;
             this.gi.bordaD.program = this.solidProgram;

             this.gi.bordaC = new Rectangle("bordaC", this.gi, 1, -1000, this.gi.gameAreaResolutionX-4, 1001, 10, new Color(1,0,0,1));
             this.gi.bordaC.isMovable = false;
             this.gi.bordaC.program = this.solidProgram;

             this.gi.bordaB = new Rectangle("bordaB", this.gi, 1, this.gi.gameAreaResolutionY-2, this.gi.gameAreaResolutionX, 2, 10, new Color(0,0,0,1));
             this.gi.bordaB.isMovable = false;
             this.gi.bordaB.program = this.solidProgram;

             this.gi.quad = new Quadtree(new RectangleM(0,0,this.gi.gameAreaResolutionX,this.gi.gameAreaResolutionY),5,5);

             this.gi.addTarget(new Target("target", this.gi, 1.0f, 1.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 102.0f, 1.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 204.0f, 1.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 308.0f, 1.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 410.0f, 1.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 1.0f, 24.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 102.0f, 24.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 204.0f, 24.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 308.0f, 24.0f, 100.0f, 20.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 410.0f, 24.0f, 100.0f, 20.0f, 10));


             for (int i = 0; i < this.gi.targets.size(); i++){
                 this.gi.targets.get(i).textureId = 2;
                 this.gi.targets.get(i).program = imageProgram;
             }
     */



             //SetupTargets();

             // Create the image information
             //SetupImage();
             // Create our texts
             //SetupText();

             /*

             this.gi.addTarget(new Target("target", this.gi, 100.0f, 300.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 202.0f, 300.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 304.0f, 300.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 406.0f, 300.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 508.0f, 300.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 100.0f, 335.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 202.0f, 335.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 304.0f, 335.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 406.0f, 335.0f, 100.0f, 30.0f, 10));
             this.gi.addTarget(new Target("target", this.gi, 508.0f, 335.0f, 100.0f, 30.0f, 10));

             for (int i = 0; i < 50; i++) {
                 this.gi.addBall((new Ball("ball", this.gi, 100.0f + (i*1), 100.0f, 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 150.0f + (i*1), 100.0f, 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 200.0f, 100.0f + (i*1), 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 250.0f, 100.0f + (i*1), 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 300.0f, 100.0f + (i*1), 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 350.0f + (i*1), 100.0f, 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 400.0f + (i*1), 100.0f, 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 450.0f + (i*1), 100.0f, 20.0f, 10)));

                 this.gi.addBall((new Ball("ball", this.gi, 100.0f + (i*1), 200.0f, 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 150.0f + (i*1), 200.0f, 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 200.0f + (i*1), 200.0f, 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 250.0f, 200.0f + (i*1), 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 300.0f + (i*1), 200.0f, 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 350.0f + (i*1), 200.0f, 10.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 400.0f + (i*1), 200.0f, 20.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 450.0f + (i*1), 200.0f, 20.0f, 10)));

                 this.gi.addBall((new Ball("ball", this.gi, 100.0f, 300.0f + (i*1), 1.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 150.0f + (i*1), 300.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 200.0f, 300.0f + (i*1), 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 250.0f + (i*1), 300.0f, 1.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 300.0f + (i*1), 300.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 350.0f + (i*1), 300.0f, 1.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 400.0f + (i*1), 300.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 450.0f + (i*1), 300.0f, 2.0f, 10)));

                 this.gi.addBall((new Ball("ball", this.gi, 100.0f - (i*1), 150.0f, 1.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 170.0f + (i*1), 150.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 200.0f - (i*1), 150.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 270.0f - (i*1), 150.0f, 1.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 300.0f - (i*1), 150.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 370.0f + (i*1), 150.0f, 1.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 400.0f - (i*1), 150.0f, 2.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 450.0f + (i*1), 150.0f, 2.0f, 10)));

                 this.gi.addBall((new Ball("ball", this.gi, 120.0f, 450.0f + (i*1), 15.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 150.0f, 450.0f - (i*1), 25.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 220.0f, 450.0f + (i*1), 25.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 250.0f, 450.0f - (i*1), 15.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 320.0f, 450.0f + (i*1), 25.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 350.0f, 450.0f - (i*1), 15.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 420.0f, 450.0f + (i*1), 25.0f, 10)));
                 this.gi.addBall((new Ball("ball", this.gi, 450.0f, 450.0f - (i*1), 25.0f, 10)));
             }
             */
         }



           private void Render(float[] m) {

                 GLES20.glUseProgram(this.imageProgram.get());

                 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
                 GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

                 // get handle to vertex shader's vPosition member and add vertices
                 int mPositionHandle = GLES20.glGetAttribLocation(this.imageProgram.get(), "vPosition");
                 GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, 0, this.gi.balls.get(0).verticesBuffer);
                 GLES20.glEnableVertexAttribArray(mPositionHandle);

                 // Get handle to texture coordinates location and load the texture uvs
                 int mTexCoordLoc = GLES20.glGetAttribLocation(this.imageProgram.get(), "a_texCoord" );
                 GLES20.glVertexAttribPointer ( mTexCoordLoc, 2, GLES20.GL_FLOAT, false, 0, this.gi.balls.get(0).uvBuffer);
                 GLES20.glEnableVertexAttribArray ( mTexCoordLoc );

                 // Get handle to shape's transformation matrix and add our matrix
                 int mtrxhandle = GLES20.glGetUniformLocation(this.imageProgram.get(), "uMVPMatrix");
                 GLES20.glUniformMatrix4fv(mtrxhandle, 1, false, m, 0);

                 // Get handle to textures locations
                 // Set the sampler texture unit to 0, where we have saved the texture.
                 int mSamplerLoc = GLES20.glGetUniformLocation (this.imageProgram.get(), "s_texture" );
                 GLES20.glUniform1i ( mSamplerLoc, 0);

                 // Draw the triangle
                 GLES20.glDrawElements(GLES20.GL_TRIANGLES, this.gi.balls.get(0).indicesData.length, GLES20.GL_UNSIGNED_SHORT, this.gi.balls.get(0).indicesBuffer);

                 // Disable vertex array
                 GLES20.glDisableVertexAttribArray(mPositionHandle);
                 GLES20.glDisableVertexAttribArray(mTexCoordLoc);

             }


package ultno.marcelslum.ultnogame;


import android.opengl.GLES20;
import android.util.Log;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.ShortBuffer;
import java.util.Iterator;
import java.util.Vector;

public class TextManager {

    private static final float RI_TEXT_UV_BOX_WIDTH = 0.0625f;
    private static final float RI_TEXT_TEXTURE_SIZE = 512.0f;
    private static final float RI_TEXT_WIDTH = 64.0f;
    private static final float RI_TEXT_SPACESIZE = 20f;

    private FloatBuffer vertexBuffer;
    private FloatBuffer textureBuffer;
    private FloatBuffer colorBuffer;
    private ShortBuffer drawListBuffer;

    private float[] vecs;
    private float[] uvs;
    private short[] indices;
    private float[] colors;

    private int index_vecs;
    private int index_indices;
    private int index_uvs;
    private int index_colors;

    private int texturenr;

    private float uniformscale;

    public static int[] l_size = {
            8, 8,	6,	9,	16,	13,	14,	16,	5,	8,	8,	8,	12,	6,	10,	6,
            13, 14,	8,	13,	14,	14,	13,	13,	13,	14,	14,	6,	6,	9,	12,	9,
            13, 21,	14,	14,	13,	13,	13,	13,	13,	14,	6,	11,	14,	11,	17,	14,
            14, 13,	14,	13,	13,	13,	14,	13,	17,	13,	13,	13,	8,	13,	7,	10,
            14, 6,	14,	13,	14,	14,	14,	10,	14,	13,	6,	5,	13,	6,	17,	14,
            14, 13,	14,	11,	14,	10,	14,	13,	17,	13,	14,	14,	10,	5,	10,	11,
            8, 13,	8,	8,	8,	8,	8,	8,	8,	8,	8,	8,	11,	21,	8,	8,
            8, 8,	6,	6,	11,	11,	6,	13,	16,	8,	19,	8,	11,	23,	8,	8,
            13, 8,	6,	13,	14,	15,	13,	8,	8,	12,	14,	8,	13,	8,	8,	14,
            8, 9,	12,	8,	8,	6,	13,	13,	8,	8,	8,	8,	13,	8,	8,	8,
            13, 13,	13,	13,	13,	13,	13,	21,	13,	13,	13,	13,	14,	6,	6,	10,
            11, 8,	13,	13,	13,	13,	13,	13,	8,	8,	13,	13,	13,	13,	13,	8,
            8, 13,	13,	13,	13,	13,	13,	23,	13,	13,	13,	13,	13,	6,	6,	8,
            11, 8,	13,	13,	13,	13,	13,	13,	13,	8,	13,	13,	13,	13,	13,	8
    };

    public Vector<Text> txtcollection;

    public TextManager()
    {
        // Create our container
        txtcollection = new Vector<Text>();

        // Create the arrays
        vecs = new float[3 * 10];
        colors = new float[4 * 10];
        uvs = new float[2 * 10];
        indices = new short[10];

        // init as 0 as default
        texturenr = 0;
    }

    public void addText(Text obj)
    {
        // Add text object to our collection
        txtcollection.add(obj);
    }

    public void setTextureID(int val)
    {
        texturenr = val;
    }


    public void AddCharRenderInformation(float[] vec, float[] cs, float[] uv, short[] indi)
    {
        // We need a base value because the object has indices related to
        // that object and not to this collection so basicly we need to
        // translate the indices to align with the vertexlocation in ou
        // vecs array of vectors.
        short base = (short) (index_vecs / 3);

        // We should add the vec, translating the indices to our saved vector
        for(int i=0;i<vec.length;i++)
        {
            vecs[index_vecs] = vec[i];
            index_vecs++;
        }

        // We should add the colors, so we can use the same texture for multiple effects.
        for(int i=0;i<cs.length;i++)
        {
            colors[index_colors] = cs[i];
            index_colors++;
        }

        // We should add the uvs
        for(int i=0;i<uv.length;i++)
        {
            uvs[index_uvs] = uv[i];
            index_uvs++;
        }

        // We handle the indices
        for(int j=0;j<indi.length;j++)
        {
            indices[index_indices] = (short) (base + indi[j]);
            index_indices++;
        }
    }

    public void PrepareDrawInfo()
    {
        // Reset the indices.
        index_vecs = 0;
        index_indices = 0;
        index_uvs = 0;
        index_colors = 0;

        // Get the total amount of characters
        int charcount = 0;
        for (Text txt : txtcollection) {
            if(txt!=null)
            {
                if(!(txt.text==null))
                {
                    charcount += txt.text.length();
                }
            }
        }

        // Create the arrays we need with the correct size.
        vecs = null;
        colors = null;
        uvs = null;
        indices = null;

        vecs = new float[charcount * 12];
        colors = new float[charcount * 16];
        uvs = new float[charcount * 8];
        indices = new short[charcount * 6];

    }

    public void PrepareDraw()
    {
        // Setup all the arrays
        PrepareDrawInfo();

        // Using the iterator protects for problems with concurrency
        for(Iterator<Text> it = txtcollection.iterator(); it.hasNext() ; )
        {
            Text txt = it.next();
            if(txt!=null)
            {
                if(!(txt.text==null))
                {
                    Log.e("size on prepare ", " "+txt.size);
                    convertTextToTriangleInfo(txt);
                }
            }
        }
    }

    public void Draw(float[] m)
    {
        // Set the correct shader for our grid object.
        GLES20.glUseProgram(GraphicTools.sp_Text);

        // The vertex buffer.
        ByteBuffer bb = ByteBuffer.allocateDirect(vecs.length * 4);
        bb.order(ByteOrder.nativeOrder());
        vertexBuffer = bb.asFloatBuffer();
        vertexBuffer.put(vecs);
        vertexBuffer.position(0);

        // The vertex buffer.
        ByteBuffer bb3 = ByteBuffer.allocateDirect(colors.length * 4);
        bb3.order(ByteOrder.nativeOrder());
        colorBuffer = bb3.asFloatBuffer();
        colorBuffer.put(colors);
        colorBuffer.position(0);

        // The texture buffer
        ByteBuffer bb2 = ByteBuffer.allocateDirect(uvs.length * 4);
        bb2.order(ByteOrder.nativeOrder());
        textureBuffer = bb2.asFloatBuffer();
        textureBuffer.put(uvs);
        textureBuffer.position(0);

        // initialize byte buffer for the draw list
        ByteBuffer dlb = ByteBuffer.allocateDirect(indices.length * 2);
        dlb.order(ByteOrder.nativeOrder());
        drawListBuffer = dlb.asShortBuffer();
        drawListBuffer.put(indices);
        drawListBuffer.position(0);

        // get handle to vertex shader's vPosition member
        int mPositionHandle = GLES20.glGetAttribLocation(GraphicTools.sp_Text, "vPosition");

        // Enable a handle to the triangle vertices
        GLES20.glEnableVertexAttribArray(mPositionHandle);

        // Prepare the background coordinate data
        GLES20.glVertexAttribPointer(mPositionHandle, 3,
                GLES20.GL_FLOAT, false,
                0, vertexBuffer);

        int mTexCoordLoc = GLES20.glGetAttribLocation(GraphicTools.sp_Text, "a_texCoord" );

        // Prepare the texturecoordinates
        GLES20.glVertexAttribPointer ( mTexCoordLoc, 2, GLES20.GL_FLOAT,
                false,
                0, textureBuffer);

        GLES20.glEnableVertexAttribArray ( mPositionHandle );
        GLES20.glEnableVertexAttribArray ( mTexCoordLoc );

        int mColorHandle = GLES20.glGetAttribLocation(GraphicTools.sp_Text, "a_Color");

        // Enable a handle to the triangle vertices
        GLES20.glEnableVertexAttribArray(mColorHandle);

        // Prepare the background coordinate data
        GLES20.glVertexAttribPointer(mColorHandle, 4,
                GLES20.GL_FLOAT, false,
                0, colorBuffer);

        // get handle to shape's transformation matrix
        int mtrxhandle = GLES20.glGetUniformLocation(GraphicTools.sp_Text, "uMVPMatrix");

        // Apply the projection and view transformation
        GLES20.glUniformMatrix4fv(mtrxhandle, 1, false, m, 0);

        int mSamplerLoc = GLES20.glGetUniformLocation (GraphicTools.sp_Text, "s_texture" );

        // Set the sampler texture unit to our selected id
        GLES20.glUniform1i ( mSamplerLoc, texturenr);

        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_NEAREST);
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_NEAREST);

        // Draw the triangle
        GLES20.glDrawElements(GLES20.GL_TRIANGLES, indices.length, GLES20.GL_UNSIGNED_SHORT, drawListBuffer);

        // Disable vertex array
        GLES20.glDisableVertexAttribArray(mPositionHandle);
        GLES20.glDisableVertexAttribArray(mTexCoordLoc);
        GLES20.glDisableVertexAttribArray(mColorHandle);

    }



    public float getWidth(Text val){
        float initialX = 0;
        String text = val.text;
        float size = val.size;

        for(int j=0; j<text.length(); j++) {
            // get ascii value
            char c = text.charAt(j);
            int c_val = (int) c;
            int indx = convertCharToIndex(c_val);

            if (indx == -1) {
                // unknown character, we will add a space for it to be save.
                initialX += (size / 2);
                continue;
            }

            initialX += ((l_size[indx]) * (size / (RI_TEXT_TEXTURE_SIZE * RI_TEXT_UV_BOX_WIDTH)));
        }
        return initialX;
    }

    public int convertCharToIndex(int c_val)
    {
        int indx = -1;

        // Retrieve the index
        if(c_val>64&&c_val<91) // A-Z
            indx = c_val - 31;
        else if(c_val>96&&c_val<123) // a-z
            indx = c_val - 31;
        else if(c_val>47&&c_val<58) // 0-9
            indx = c_val - 32;
        else if(c_val==43) // +
            indx = 12;
        else if(c_val==45) // -
            indx = 14;
        else if(c_val==33) // !
            indx = 2;
        else if(c_val==63) // ?
            indx = 32;
        else if(c_val==61) // =
            indx = 30;
        else if(c_val==58) // :
            indx = 27;
        else if(c_val==46) // .
            indx = 15;
        else if(c_val==44) // ,
            indx = 43;
        else if(c_val==42) // *
            indx = 44;
        else if(c_val==36) // $
            indx = 45;
        else if(c_val==36) // ,???????????
            indx = 13;
        else if(c_val==36) // ã
            indx = 13;
        else if(c_val==233) //é
            indx = 201;
        else if(c_val==36) // á
            indx = 13;
        else if(c_val==36) // à
            indx = 13;
        else if(c_val==36) // ,???????????
            indx = 13;
        else if(c_val==36) // ,???????????
            indx = 13;
        else if(c_val==36) // ,???????????
            indx = 13;

        return indx;
    }

    private void convertTextToTriangleInfo(Text val)
    {


        // Get attributes from text object
        float x = val.x;
        float y = val.y;
        String text = val.text;
        float size = val.size;

        Log.e("size ", " "+size);

        // Create
        for(int j=0; j<text.length(); j++)
        {
            // get ascii value
            char c = text.charAt(j);
            Log.e("char ", " "+ c);

            int c_val = (int)c;

            Log.e("char int", " "+ c_val);

            int indx = convertCharToIndex(c_val);

            Log.e("char indx", " "+ indx);

            if(indx==-1) {
                // unknown character, we will add a space for it to be save.
                x += (size/2);
                continue;
            }

            // Calculate the uv parts
            int row = indx / 16;
            int col = indx % 16;

            float v = row * RI_TEXT_UV_BOX_WIDTH;
            float v2 = v + RI_TEXT_UV_BOX_WIDTH;
            float u = col * RI_TEXT_UV_BOX_WIDTH;
            float u2 = u + RI_TEXT_UV_BOX_WIDTH;

            // Creating the triangle information
            float[] vec = new float[12];
            float[] uv = new float[8];
            float[] colors = new float[16];

            vec[0] = x;
            vec[1] = y + size;
            vec[2] = 0.95f;
            vec[3] = x;
            vec[4] = y;
            vec[5] = 0.95f;
            vec[6] = x + size;
            vec[7] = y;
            vec[8] = 0.95f;
            vec[9] = x + size;
            vec[10] = y + size;
            vec[11] = 0.95f;

            colors = new float[]
                    {val.colorData2[0], val.colorData2[1], val.colorData2[2], val.colorData2[3],
                            val.colorData2[0], val.colorData2[1], val.colorData2[2], val.colorData2[3],
                            val.colorData2[0], val.colorData2[1], val.colorData2[2], val.colorData2[3],
                            val.colorData2[0], val.colorData2[1], val.colorData2[2], val.colorData2[3]
                    };
            // 0.001f = texture bleeding hack/fix
            uv[0] = u+0.001f;
            uv[1] = v+0.001f;
            uv[2] = u+0.001f;
            uv[3] = v2-0.001f;
            uv[4] = u2-0.001f;
            uv[5] = v2-0.001f;
            uv[6] = u2-0.001f;
            uv[7] = v+0.001f;

            short[] inds = {0, 1, 2, 0, 2, 3};

            // Add our triangle information to our collection for 1 render call.
            AddCharRenderInformation(vec, colors, uv, inds);

            // Calculate the new position



            x += ((l_size[indx])*(size/(RI_TEXT_TEXTURE_SIZE*RI_TEXT_UV_BOX_WIDTH)));
        }
    }

}


 public void loadLevel(int levelNumber){
        switch (levelNumber){
            case 1:
                levelObject = new Level(levelNumber, this);
                levelObject.ballsQuantity = 1;
                levelObject.minBallsNotInvencibleAlive = 1;
                levelObject.ballsRadiusByResolution = new float[]{0.010f, 0.010f};
                levelObject.ballsInitialXByResolution = new float[]{0.3f, 0.5f};
                levelObject.ballsInitialYByResolution = new float[]{0.5f, 0.5f};
                levelObject.ballsDesiredVelocityXByResolution = new float[]{0.003f, 0.003f};
                levelObject.ballsDesiredVelocityYByResolution = new float[]{0.00529412f, 0.00529412f};
                levelObject.ballsColor = new Color[] {new Color(1f, 1f, 1f, 1f),new Color(1f, 1f, 1f, 1f)};
                levelObject.ballsInvencible = new boolean[]{false, false};
                levelObject.ballsAngleToRotate = new float[]{2f, 2f};
                levelObject.ballsMaxAngle = new float[]{55f, 55f};
                levelObject.ballsMinAngle = new float[]{35f, 35f};
                levelObject.ballsVelocityVariation = new float[]{0.1f, 0.1f};
                levelObject.ballsVelocityMaxByInitialVelocity = new float[]{1.5f, 1.5f};
                levelObject.ballsVelocityMinByInitialVelocity = new float[]{0.8f, 0.8f};
                levelObject.ballsTargetsAppend = (ArrayList<Target>[]) new ArrayList[10];
                levelObject.ballsFree = new boolean[]{true, true};
                levelObject.barsQuantity = 1;
                levelObject.barsSizeXByResolution = new float[]{0.22f};//0.22f};//
                levelObject.barsSizeYByResolution = new float[]{0.0175f};//0.0125f};//
                levelObject.barsInitialXByResolution = new float[]{0.3f};//0.3f
                levelObject.barsInitialYByResolution = new float[]{0.024f};//0.014f};
                levelObject.barsDesiredVelocityXByResolution = new float[]{0.0045f};
                levelObject.barsDesiredVelocityYByResolution = new float[]{0f};

                levelObject.quantityTargetsX = 10;//10ocupa 11 espaços
                levelObject.quantityTargetsY = 2;
                levelObject.targetSizeXByResolution = 0.0895f;
                levelObject.targetSizeYByResolution = 0.04f;
                levelObject.targetsDistanceByXResolution = 0.001f;
                levelObject.targetsPaddingByXResolution = 0.00225f;

                final float quantityTargetsY = levelObject.quantityTargetsY;
                final float quantityTargetsX = levelObject.quantityTargetsX;
                final float targetsDistanceByXResolution = levelObject.targetsDistanceByXResolution;
                final float targetsPaddingByXResolution = levelObject.targetsPaddingByXResolution;
                final float targetSizeXByResolution = levelObject.targetSizeXByResolution;
                final float targetSizeYByResolution = levelObject.targetSizeYByResolution;
                final float gameAreaResolutionX = this.gameAreaResolutionX;
                final float gameAreaResolutionY = this.gameAreaResolutionY;
                final Game game = this;

                Log.e("game", "2");
                levelObject.setEntitiesCreator(new Level.EntitiesCreator() {
                    @Override
                    public void createTargets() {

                        Log.e("game", "p4");
                        for (int iY = 0; iY < quantityTargetsY;iY++){
                            for (int iX = 0; iX < quantityTargetsX; iX++) {
                                if (!(iY == 0 && iX == 0)){

                                    float xInitial = (gameAreaResolutionX * targetsPaddingByXResolution) + (iX * ((gameAreaResolutionX * targetSizeXByResolution) + (gameAreaResolutionX * targetsDistanceByXResolution)));
                                    float yInitial = (gameAreaResolutionX * targetsPaddingByXResolution) + (iY * ((gameAreaResolutionY * targetSizeYByResolution) + (gameAreaResolutionX * targetsDistanceByXResolution)));

                                    Target target = new Target("target", game, xInitial, yInitial,
                                            gameAreaResolutionX * targetSizeXByResolution,
                                            gameAreaResolutionY * targetSizeYByResolution, 9
                                            );
                                    target.isMovable = false;
                                    target.alpha = 1;
                                    target.states = new int[]{0,1};
                                    target.currentState = 1;
                                    game.addTarget(target);
                                    Log.e("game", "p5");
                                }
                            }
                        }
                    }

                    @Override
                    public void createObstacles() {

                    }

                    @Override
                    public void createWindows() {

                    }
                });

                Log.e("game", "3");
                break;
        }
    }




OBSTACLE

 sizeOfSquaresY = (getHeight()/getTransformedHeight())* (game.resolutionX/50f);

        int squaresOnX = (int)Math.floor(getWidth() / sizeOfSquaresX);
        float restX = getWidth() % sizeOfSquaresX;

        int squaresOnY = (int)Math.floor(getHeight() / sizeOfSquaresY);
        float restY = getHeight() % sizeOfSquaresY;

        //Log.e("obstacles", "sizeOfSquaresY "+sizeOfSquaresY);
        //Log.e("obstacles", "squaresOnY "+squaresOnY);
        //Log.e("obstacles", "restY "+restY);

        if (lastSquaresOnY != squaresOnY && lastSquaresOnY != 0){
            if (!midUpY) {
                midUpY = true;
            } else {
                midUpY = false;
            }
        }
        lastSquaresOnY = squaresOnY;

        if (lastSquaresOnX != squaresOnX && lastSquaresOnX != 0){
            if (!midUpX) {
                midUpX = true;
            } else {
                midUpX = false;
            }
        }
        lastSquaresOnX = squaresOnX;

        if (restX > 0){
            if (midUpX){
                squaresOnX += 1;
                restX = (getWidth() - ((squaresOnX - 2)*sizeOfSquaresX))/2f;
            } else {
                restX /= 2f;
                squaresOnX += 2;
            }
        }

        if (restY > 0){
            if (midUpY){
                squaresOnY += 1;
                restY = (getHeight() - ((squaresOnY - 2)*sizeOfSquaresY))/2f;
            } else {
                restY /= 2f;
                squaresOnY += 2;
            }
        }

        //Log.e("obstacles", "midUpY "+midUpY);
        //Log.e("obstacles", "squaresOnY "+squaresOnY);
        //Log.e("obstacles", "restY "+restY);


        int totalSquares = squaresOnY * squaresOnX;
        initializeData(12 * totalSquares, 6 * totalSquares, 8 * totalSquares, 0);
        int squareInserted = 0;
        float posY;
        float posX;
        float w;
        float h;
        boolean invertUvY;
        boolean invertUvX;
        for (int iY = 0; iY < squaresOnY; iY++) {
            invertUvY = false;
            invertUvX = false;
            if (restY != 0f){
                if (iY == 0){
                    posY = 0f;
                    h = restY;
                } else if (iY == (squaresOnY-1)) {
                    posY = restY + (sizeOfSquaresY * (iY-1));
                    h = restY;
                    invertUvY = true;
                } else {
                    posY = restY + (sizeOfSquaresY * (iY-1));
                    h = sizeOfSquaresY;
                }
            } else {
                posY = sizeOfSquaresY * iY;
                h = sizeOfSquaresY;
            }

            for (int iX = 0; iX < squaresOnX; iX++) {
                if (restX != 0f){
                    if (iX == 0){
                        posX = 0f;
                        w = restX;
                    } else if (iX == squaresOnX-1) {
                        posX = restX + (sizeOfSquaresX * (iX-1));
                        w = restX;
                        invertUvX = true;
                    } else {
                        posX = restX + (sizeOfSquaresX * (iX-1));
                        w = sizeOfSquaresX;
                    }
                } else {
                    posX = sizeOfSquaresX * iX;
                    w = sizeOfSquaresX;
                }

                //Log.e("obstacle", " pos X "+posX+" Y "+posY +" w "+w+" h "+h);


                 // cria o seletor de volume
                        selectorVolumn = new Selector("selectorVolumn",0f,0f, 40f, "", volumns, font);
                        final Selector innerSelectorVolumn = selectorVolumn;
                        selectorVolumn.setOnChange(new Selector.OnChange() {
                            @Override
                            public void onChange() {
                                Game.volume = Game.possibleVolums[innerSelectorVolumn.selectedValue];
                                Storage.setVolume(Game.volume);
                            }
                        });

                        // adiciona a opção de alterar volume
                        menuMain.addMenuOption("AlterarVolume", context.getResources().getString(R.string.menuPrincipalAlterarVolume), new MenuOption.OnChoice() {
                            @Override
                            public void onChoice() {
                                innerSelectorVolumn.fromMenu(innerMenu);
                                int volumeToSelector = volume / 10;
                                innerSelectorVolumn.setSelectedValue(volumeToSelector);
                            }
                        });

                        // ajusta a posição do seletor de nível
                        MenuOption menuOptionSelectVolumn = menuMain.getMenuOptionByName("AlterarVolume");
                        selectorVolumn.setPosition(menuOptionSelectLevel.x + (menuOptionSelectVolumn.width), menuOptionSelectVolumn.y);